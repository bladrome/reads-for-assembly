#! /usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import random
import configparser

import anvio.utils as u
import anvio.fastalib as fastalib
import anvio.terminal as terminal

pp = terminal.pretty_print

bases = ['A', 'T', 'C', 'G', 'N']


class Configuration:
    def __init__(self, config):
        self.sanity_check(config)

        self.output_sample_name = user_config.get('general', 'output_sample_name')
        self.insert_size = int(user_config.get('general', 'insert_size'))
        self.insert_size_std = float(user_config.get('general', 'insert_size_std'))
        self.short_read_length = int(user_config.get('general', 'short_read_length'))
        self.error_rate = float(user_config.get('general', 'error_rate'))

        self.fasta_files = []
        self.fasta_files_dict = {}

        for section in [s for s in config.sections() if s != 'general']:
            alias = os.path.basename('.'.join(section.split('.')[:-1]))
            self.fasta_files.append(alias)
            self.fasta_files_dict[alias] = {'path': section,
                                            'alias': alias,
                                            'coverage': int(user_config.get(section, 'coverage'))}


    def sanity_check(self, config):
        # don't have any interest in implementing this right now.
        pass


def simulate_errors(error_rate, sequence):
    sequence_with_errors = ''
    num_errors = 0

    if error_rate > 0:
        threshold = 1000 * error_rate
        for i in range(0, len(sequence)):
            if random.randint(0, 1000) < threshold:
                sequence_with_errors += random.choice(bases)
                num_errors += 1
            else:
                sequence_with_errors += sequence[i]
    else:
        sequence_with_errors = sequence

    return sequence_with_errors, num_errors


def main(config):
    run = terminal.Run(width = 25)
    progress = terminal.Progress()

    output_r1 = open(config.output_sample_name + '-R1.fastq', 'w')
    output_r2 = open(config.output_sample_name + '-R2.fastq', 'w')

    run.info('Read lenth', config.short_read_length)
    run.info('Insert size', config.insert_size)
    run.info('Insert size std', config.insert_size_std)

    x = config.short_read_length
    Q_str = ''.join(['A'] * x)

    for i in range(0, len(config.fasta_files)):
        f = config.fasta_files_dict[config.fasta_files[i]]

        c = f['coverage']

        progress.new('Working on file %d of %d (%s) with expected coverage of %d' % (i + 1, len(config.fasta_files), f['alias'], c))

        fasta = fastalib.SequenceSource(f['path'])
        total_r1_errors = 0
        total_r2_errors = 0
        while next(fasta):
            L = len(fasta.seq)

            av_num_pairs_needed = int((L / x * c) / 2)

            for i in range(0, av_num_pairs_needed):
                if (i + 1) % 100 == 0:
                    progress.update('Seq %s :: %s nts :: reads %s of %s :: num errors: %s ...'\
                                                    % (pp(fasta.pos + 1), pp(len(fasta.seq)),
                                                       pp(i + 1), pp(av_num_pairs_needed),
                                                       pp(total_r1_errors + total_r2_errors)))

                I = int(round(random.gauss(config.insert_size, config.insert_size_std)))
                start_pos = random.randint(0, L - ((x * 2) + I))

                read_1_start = start_pos
                read_1_stop = read_1_start + x

                read_2_start = read_1_stop + I
                read_2_stop = read_2_start + x

                read_1, num_errors_r1 = simulate_errors(config.error_rate, fasta.seq[read_1_start:read_1_stop])
                read_2, num_errors_r2 = simulate_errors(config.error_rate, fasta.seq[read_2_start:read_2_stop])

                total_r1_errors += num_errors_r1
                total_r2_errors += num_errors_r2

                c1, c2 = random.randint(1, 10000), random.randint(1, 10000)
                output_r1.write('@%s:23:B02CBACXX:8:2315:%d:%d 1:N:0:GATCAG\n' % (f['alias'], c1, c2))
                output_r1.write(read_1 + '\n')
                output_r1.write('+source:%s; start:%d; stop:%d; insert_size:%d\n' % (fasta.id, read_1_start, read_1_stop, I))
                output_r1.write('%s\n' % Q_str)

                output_r2.write('@%s:23:B02CBACXX:8:2315:%d:%d 2:N:0:GATCAG\n' % (f['alias'], c1, c2))
                output_r2.write(u.rev_comp(read_2) + '\n')
                output_r2.write('+source:%s; start:%d; stop:%d; insert_size:%d\n' % (fasta.id, read_2_start, read_2_stop, I))
                output_r2.write('%s\n' % Q_str)

        progress.end()
        total_num_errors = total_r1_errors + total_r2_errors
        run.info(f['alias'], '%s paired-end reads w/ %s errors (average rate of %.4f) generated for %sX average coverage.'\
                                    % (pp(av_num_pairs_needed),
                                       pp(total_num_errors),
                                       total_num_errors * 1.0 / (av_num_pairs_needed * x * 2),
                                       pp(c),
                                       ))

    output_r1.close()
    output_r2.close()
    run.info('FASTQ R1',config.output_sample_name + '-R1.fastq')
    run.info('FASTQ R2',config.output_sample_name + '-R2.fastq')


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Generate short reads from contigs')
    parser.add_argument('configuration', metavar = 'CONFIG_FILE',
                                        help = 'Configuration file')

    args = parser.parse_args()
    user_config = configparser.ConfigParser()
    user_config.read(args.configuration)

    config = Configuration(user_config)
    sys.exit(main(config))
